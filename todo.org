* eopl
- [eopl.lang_module]
- [eopl.lang_class]
- [eopl] note about further reading
* jojo
- [adventure.simple] `type <name> = { ... }`
- [adventure.simple] representing data types
- [adventure.simple] paper
- [adventure.counted] annotation for arg_count and ret_count
- [adventure.counted] infer arg_count and ret_count
- [adventure.counted] eq by eval
- [adventure.counted] encode permutation group
- [adventure.jojo_untyped] [bug] tail-call (let x) is not correct
  - [maybe] use explicit tail call
* de_bruijn
- [de_bruijn] `let type <name> = ...`
- [de_bruijn] representing data types
- [de_bruijn_logical]
  - view type atom as logic variable and use unification
  - this should be a different language from [de_bruijn]
- [de_bruijn] synth
- theory about equality between lambda terms
  - reflexivity
    symmetry
    transitivity
    congruence
    beta_reduction
    eta_reduction
* miniml
- [miniml] the CAM machine
* the little mler
- as test for some of the languages
* lambda
- church's encoding and the unsolvable problem paper
- can norm-by-eval handle call-by-name terms ?
- what are examples of call-by-value bad terms ?
* curry
- [curry] view type atom as logic variable and use unification
  - type system of curry style need type variable
    there is no version of curry style without type variable
* tartlet
- [tartlet] extend tartlet to pie
- [tartlet] use `TODO` as un-implemented
- [tartlet] block of let and return
- [tartlet] extend tartlet to define new inductive types
  - keep it subrecursive
  - generate data and ind, rec and iter
- [tartlet] add cumulative (maybe non-cumulative) levels of types -- type^n
- [to be sure] why we *do need* "type directed norm-by-eval" here ?
- [to be sure] about the use of TheVal and friends
- [test] eta conversion: f == (x) => f(x)
* the little typer
- as test for dependently typed language
* pure type system
- in addition to a file to eval, also a file of config of sorts, axioms and rules
- logic framework is a special case of pure type system ?
  plus a single subtyping-like rule
  A: Set --> A: Type
  - where `Set` is inductively generate datatype
* sysf
* minitt
- [note] why we *do not need* "type directed norm-by-eval" here ?
- [question] I think the use of NormEnv will break `equals`
- add `eqv_t` `same` `replace`
- add constrains to type constructors
- why not jsut use letrec for every definition ? -- learn from EOPL
- add cumulative (maybe non-cumulative) levels of types -- type_t(n)
- be sure about the use of Pattern
  - write some notes
  - Norm do not use Pattern
  - note about how letrec is handled at lookup-time
* module system
* partech
- [partech] rewrite in c
- [partech] ErrMsg and Span
- [partech] better report with ErrMsg in context
* compile with cps
* sat
- sat solver visualization (how ?)
* complexity
- cook's machine for trans algo to lin-algo
* lambda machine
- new machine for call-by-name or call-by-need lambda
* term rewriting
* dsl
- generative art
- formal concept analysis
- cell complex
- four dancing circles
* for readme
- [barendregt/curry](src/main/scala/xieyuheng/barendregt/curry) <br>
  - Curry style simple type lambda calculus.
- [pure](src/main/scala/xieyuheng/pure) <br>
  - A framework for the essence of dependent type system, <br>
    which can be viewed as an extension of Barendregt's lambda cube.
- [miniml](src/main/scala/xieyuheng/miniml) <br>
  - "A simple applicative language: Mini-ML", <br>
    by Dominique Clement, Joelle Despeyroux, Thierry Despeyroux, Gilles Kahn.
- [adventure/jojo_counted](src/main/scala/xieyuheng/adventure/jojo_counted) <br>
  - The language `jojo_untyped` plus annotation for number of arguments and number of return values.
  - An equivalent predicate for jojo, inspired by `nbe`.
- [adventure/jojo_dependent](src/main/scala/xieyuheng/adventure/jojo_dependent) <br>
  - Two levels of computations -- `exe` and `cut`, where `cut` is as powerful as `exe`.
* formal concept analysis
* method of analytic tableaux
* formal specification
